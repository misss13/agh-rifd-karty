#include <SPI.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <WiFiAP.h>
#include "UART.h"

#define LED_BUILTIN 2
#define SS_PIN 21
#define RST_PIN 22
#define SIZE_BUFFER 18
#define MAX_SIZE_BLOCK 16
#define greenPin 12

MFRC522::MIFARE_Key key;
MFRC522::StatusCode status;
MFRC522 mfrc522(SS_PIN, RST_PIN);

void readingData();

//eprom zajmiemy stanami więc wsm zmiana hasła troche mi nie siada pozatym dane trzeba gdzieś trzymać 
const char *ssid = "yourAP";
const char *password = "yourPassword";

IPAddress PageIP(192, 168, 1, 1);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 255, 0);
WiFiServer server(80);

void setup(){
  pinMode(LED_BUILTIN, OUTPUT);

  mfrc522.PCD_Init();

  UART::init();
  UART::println("AP constructing");

  WiFi.softAP(ssid, password);
  server.begin();
  mfrc522.PCD_Init();

  UART::println("Server UP");
}

void loop() {
  UART::tick();

  WiFiClient client = server.available();

  if (client) {                       
    UART::println("New client connected");
    String currentLine = "";
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        if (c == '\n') {
          if (currentLine.length() == 0) {
            client.println("HTTP/1.1 200 OK");
            client.println("Content-type:text/html");
            client.println();

            client.print("<button onclick=\"window.location.href='/prog'\">Tryb programowania</button><br/>");
            client.print("<button onclick=\"window.location.href='/once'\">Otworz drzwi raz</button><br/>");
            client.print("<button onclick=\"window.location.href='/multi'\">Otworz drzwi na kilka minut</button><br/>");
            client.print("<button onclick=\"window.location.href='/bis'\">Tryb bistabilny</button><br/>"); //po przyłożeniu karty drzwi się zamukają
            client.print("<button onclick=\"window.location.href='/list'\">Lista kart</button><br/>");
            
            client.println();
            break;
          } else {
            currentLine = "";
          }
        } else if (c != '\r') {
          currentLine += c;
        }
        if (currentLine.endsWith("GET /prog")) {
          digitalWrite(LED_BUILTIN, HIGH);
          //func
        }
        if (currentLine.endsWith("GET /once")) {
          digitalWrite(LED_BUILTIN, LOW);
          //func
        }
        if (currentLine.endsWith("GET /multi")) {
          digitalWrite(LED_BUILTIN, HIGH); 
          //func
        }
        if (currentLine.endsWith("GET /bis")) {
          digitalWrite(LED_BUILTIN, LOW);
          //func
        }
        if (currentLine.endsWith("GET /list")) {
          digitalWrite(LED_BUILTIN, HIGH); 
          //func
        }
      }
    }
    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
    client.stop();
    UART::println("Client Disconnected.");
  }
}


void readingData(){

mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid));

for (byte i = 0; i < 6; i++) key.keyByte[i] = 0xFF;
byte buffer[SIZE_BUFFER] = {0};

byte block = 1;
byte size = SIZE_BUFFER;
status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, block, &key, &(mfrc522.uid)); //line 834 of MFRC522.cpp file
if (status != MFRC522::STATUS_OK) {
void UART::print_error
Serial.print(F("Authentication failed: "));
Serial.println(mfrc522.GetStatusCodeName(status));
return;
}


status = mfrc522.MIFARE_Read(block, buffer, &size);
if (status != MFRC522::STATUS_OK) {
Serial.print(F("Reading failed: "));
Serial.println(mfrc522.GetStatusCodeName(status));
digitalWrite(greenPin, HIGH);
delay(1000);
digitalWrite(greenPin, LOW);
return;
}
else{
digitalWrite(greenPin, HIGH);
delay(1000);
digitalWrite(greenPin, LOW);
}

Serial.print(F("\nData from block ["));
Serial.print(block, HEX);Serial.print(F("]: "));

//prints read data
for (uint8_t i = 0; i < MAX_SIZE_BLOCK; i++)
{
Serial.write(buffer[i]);
}
Serial.println(" ");
}
